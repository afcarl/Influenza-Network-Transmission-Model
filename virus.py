from random import random, randint, choice
from segment import Segment
from copy import deepcopy
from host import Host
from datetime import datetime
from joblib import Parallel, delayed

import hashlib

class Virus(object):
	"""
	The Virus class is at the third highest level in the viral simulator. The 
	Virus class is a metaphor for any pathogen; because this simulator is being
	written first for a Viral pathogen as opposed to a different one, we will 
	for now stick with the Virus class name. In the future, this will be 
	generalized to a generic Pathogen class.
	TODO: RENAME VIRUS CLASS TO PATHOGEN.

	----------

	ATTRIBUTES

	- STRING: id
		a unique identifier for the virus object, generated by concatenating a 
		random number with the current local time, and then hashing it.

	- LIST OF OBJECTS: segments 
		a list of viral Segment objects that belong to the virus.
	
	- VARIABLE: parent
		a variable that references another virus as its parent, if descended 
		from a single virus, or a tuple of two viruses, if it is a reassorted 
		progeny.
	
	- TUPLE: burst_size_range
		a two-tuple that specifies the minimum and maximum number of viruses 
		that come out of one replication cycle.

	- FLOAT: generation_time
	 	an integer that specifies how long it takes (in minutes) for one 
	 	replication cycle to take place.

	----------

	MAIN METHODS

	- mutate:
	 	a method that mutates all of the segments present in the virus 
	 	according to the mutation rate of the virus.

	- replicate: 
	 	a method that returns a copy of the virus. The mutate function is
	 	guaranteed to be called.

	- generate_progeny:
	 	a method that returns a list of progeny that were replicated out of the
	 	virus.

	The methods described above are the main and important methods; the other
	methods in this class are mostly helper methods that do getting/setting of 
	attributes (with type checking for setters).
	"""
	
	def __init__(self, creation_date, host, num_segments=2, parent=None, \
		generate_sequence=True, burst_size_range=(5, 50), \
		generation_time=30):
		"""
		Initiailize the virus with 2 segments, with default segment length.
		"""
		super(Virus, self).__init__()

		# variable that records the id of the Virus in the Environment.
		self.id = None
		self.set_id()

		# variable that references to the parent Virus object.
		self.parent = None
		self.set_parent(parent)

		# # Boolean variable that records whether this virus was reassorted from 
		# # two parents or not.
		# # TODO: TO BE DEPRECATED, AS THIS CAN BE INFERRED FROM THE PARENTS
		# # VARIABLE
		# self.reassorted = None
		# self.set_reassorted_status(False) 

		# An integer number describing the time step in which a virus was 
		# generated.
		self.creation_date = None
		self.set_creation_date(creation_date)

		# List of segments present in the virus. This is changed 
		# in SmallFluVirus.
		self.segments = []
		self.generate_segments(num_segments)

		# This is the current host of the virus particle. Each virus particle
		# can only have one host.
		if type(host) != Host:
			raise TypeError('A Host object must be specified!')
		else:
			self.host = host
			host.add_virus(self)

		# Burst size is a two-tuple that describes the minimum and maximum 
		# burst size of the virus per generation/replication cycle. 
		self.burst_size_range = None
		self.set_burst_size_range(burst_size_range)

		# Generation time is an integer number that specifies, in minutes, the 
		# time from one generation to the next.
		self.generation_time = None
		self.set_generation_time(generation_time)


	def __repr__(self):
		return str(self.id)

	# def infect_host(self, host):
	# 	"""
	# 	This method will make the virus infect a specified host.
	# 	"""
	# 	if type(host) != Host:
	# 		raise TypeError('A Host object must be specified!')
	# 	else:
	# 		# Remove virus from the current host.
	# 		self.host.RemoveVirus(self)
	# 		# Set new host for the virus.
	# 		self.host = host
	# 		# Add self to the host.
	# 		host.add_virus(self)

	# def transmit_from_host_to_host(self, host1, host2):
	# 	"""
	# 	DEPRECATE: Move this to Host object.
	# 	This method will make the virus jump from one host to the next.
	# 	"""
	# 	if type(host1) != Host or type(host2) != Host:
	# 		raise TypeError('Two Host objects must be specified!')
	# 	else:
	# 		host2.add_virus(self)
	# 		host1.RemoveVirus(self)
	# 		self.host = host2

	def mutate(self, segment=None):
		"""
		This method will mutate all of the viral segments according to their 
		specified substitution rates.
		"""

		for segment in self.get_segments():
			segment.mutate()

	def generate_progeny(self, date):
		"""
		This method returns a list of progeny virus that have replicated from 
		the current virus.
		"""
		burst_size = randint(self.burst_size_range[0], \
			self.burst_size_range[1])
		# print burst_size
		progeny_viruses = []

		for i in range(burst_size):
			new_virus = self.replicate(date)
			progeny_viruses.append(new_virus)

		return progeny_viruses
		
	def replicate(self, date):
		"""
		This method returns a deep copy of the virus chosen to replicate.

		At the end, return the new virus. 

		mutate is guaranteed to be called, but not guaranteed to happen. Whether 
		a mutation occurs or not depends on the mutation rate of the virus.
		"""
		new_virus = deepcopy(self)
		new_virus.host = self.host
		new_virus.set_creation_date(date)
		new_virus.set_id()
		new_virus.set_parent(self)
		new_virus.set_reassorted_status(False)
		self.host.add_virus(new_virus)
		new_virus.mutate()

		return new_virus

	def generate_segment(self, segment_number, mutation_rate=0.03, \
		sequence=None, length=100):
		"""
		This method creates a segment with the parameters passed in.

		If the virus does not share these default parameters, then 
		"""
		segment = Segment(segment_number=segment_number, \
			mutation_rate=mutation_rate, sequence=sequence, length=length)

		return segment

	def generate_segments(self, num_segments=2, segment_lengths=(10, 10)):
		"""
		This method generates a list of segments with the tuple of segment 
		lengths passed in as a parameter. This method basically automates
		the process of creating segments.
		"""
		if num_segments != len(segment_lengths):
			raise ValueError('The number of segment lengths specified does not match the number of segments in the virus.')
			pass
		segments = []
		for i, length in enumerate(segment_lengths):
			segments.append(self.generate_segment(i, sequence=None, \
				length=length))

		return segments

	# def get_creation_date(self):
	# 	"""
	# 	This method returns the creation date of the virus.
	# 	"""
	# 	return self.creation_date

	def compute_genome_length(self):
		"""
		This method returns the length of the virus genome, summed over all    
		segments in the viral genome.
		"""
		length = sum(segment.length for segment in self.get_segments())
		return length

	# def get_id(self):
	# 	"""This method returns the ID of the virus."""
	# 	return self.id

	# def get_parent(self):
	# 	"""This method returns the ID of the virus' parent."""
	# 	return self.parent

	# def get_segments(self):
	# 	"""This method will return a list of segments."""
	# 	return self.segments

	# def get_segment(self, segment_number):
	# 	"""This method will return the particular segment specified."""
	# 	return self.segments[segment_number]

	def get_sequences(self):
		"""
		This method will return a list of sequences, one for each 
		segment.
		"""
		sequences = []

		for segment in self.segments:
			sequences.append(segment.get_sequence())

		return sequences

	def set_burst_size_range(self, burst_size_range):
		"""
		This method will set the burst size range. The burst size range must
		be passed in as a two-element list or tuple, with minimum at the first 
		position, and maximum at the second position.
		"""
		if type(burst_size_range) not in [tuple, list]:
			raise TypeError("A tuple/list of two integers must be specified!")

		if len(burst_size_range) != 2:
			raise ValueError("A two-element tuple/list must be specified!")

		if type(burst_size_range[0]) != int or type(burst_size_range[1]) != int:
			raise TypeError("Integer values of burst sizes must be specified!")

		if burst_size_range[0] > burst_size_range[1]:
			raise ValueError("The burst size range must be specified as (min, max)!")
		else:
			self.burst_size_range = burst_size_range

	def set_creation_date(self, date):
		"""This method sets the creation date of the virus."""
		self.creation_date = date

	def set_generation_time(self, generation_time):
		if type(generation_time) != int:
			raise TypeError('An integer number of minutes must be specified!')
		else:
			self.generation_time = generation_time

	def set_id(self):
		"""
		This method sets the ID of the virus to be a unique string based on
		the string representation of the current time and a randomly chosen
		number.
		"""
		random_number = str(random())
		current_time = str(datetime.now())

		unique_string = random_number + current_time

		unique_id = hashlib.new('sha512')
		unique_id.update(unique_string)
		
		self.id = unique_id.hexdigest()

	def set_parent(self, parent_virus):
		"""This method records the ID of the virus' parent."""
		if parent_virus == None:
			self.parent = None
		elif not isinstance(parent_virus, Virus):
			raise TypeError('A Virus object must be specified!')
		else:
			self.parent = parent_virus

	# def SetSegments(self, list_of_segments):
	# 	"""
	# 	This method will override all segments present in the virus. This
	# 	is essentially syntactic sugar for changing a virus wholesale;
	# 	however, use with caution.
	# 	"""
	# 	self.segments = list_of_segments

	# def set_reassorted_status(self, status):
	# 	"""This is a helper method that will set the reassortant status."""
	# 	if status not in [True, False]:
	# 		raise TypeError('A Boolean status must be specified!')
	# 	else:
	# 		self.reassorted = status

	def is_reassorted(self):
		"""This method returns the reassortant status of the virus."""
		if len(self.get_parent) == 2:
			return True

		elif len(self.get_parent) == 1:
			return False








