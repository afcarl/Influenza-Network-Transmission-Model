from random import random, randint, choice
from segment import Segment
from copy import deepcopy
from host import Host
from datetime import datetime
from joblib import Parallel, delayed

import hashlib

class Virus(object):
	"""
	The Virus class is at the third highest level in the viral simulator. The 
	Virus class is a metaphor for any pathogen; because this simulator is being
	written first for a Viral pathogen as opposed to a different one, we will 
	for now stick with the Virus class name. In the future, this will be 
	generalized to a generic Pathogen class.
	TODO: RENAME VIRUS CLASS TO PATHOGEN.

	----------

	ATTRIBUTES

	- STRING: id
		a unique identifier for the virus object, generated by concatenating a 
		random number with the current local time, and then hashing it.

	- LIST OF OBJECTS: segments 
		a list of viral Segment objects that belong to the virus.
	
	- VARIABLE: parent
		a variable that references another virus as its parent, if descended 
		from a single virus, or a tuple of two viruses, if it is a reassorted 
		progeny.
	
	- TUPLE: burst_size_range
		a two-tuple that specifies the minimum and maximum number of viruses 
		that come out of one replication cycle.

	- FLOAT: replication_time
	 	an integer that specifies how long it takes (in minutes) for one 
	 	replication cycle to take place.

	----------

	MAIN METHODS

	- mutate:
	 	a method that mutates all of the segments present in the virus 
	 	according to the mutation rate of the virus.

	- replicate: 
	 	a method that returns a copy of the virus. The mutate function is
	 	guaranteed to be called.

	- generate_progeny:
	 	a method that returns a list of progeny that were replicated out of the
	 	virus.

	The methods described above are the main and important methods; the other
	methods in this class are mostly helper methods that do getting/setting of 
	attributes (with type checking for setters).
	"""
	
	def __init__(self, creation_date, host, num_segments=2, parent=None, \
		generate_sequence=True, burst_size_range=(5, 50), \
		replication_time=30, bottleneck_size=4):
		"""
		Initiailize the virus with 2 segments, with default segment length.
		"""
		super(Virus, self).__init__()

		self.id = None
		self.set_id()

		self.parent = None
		self.set_parent(parent)

		self.creation_date = None
		self.set_creation_date(creation_date)

		self.segments = self.generate_segments(num_segments=num_segments)

		if type(host) != Host:
			raise TypeError('A Host object must be specified!')
		else:
			self.host = host
			host.add_virus(self)

		self.burst_size_range = None
		self.set_burst_size_range(burst_size_range)

		self.replication_time = None
		self.set_replication_time(replication_time)


	def __repr__(self):
		return str(self.id)

	def get_sequence(self):
		sequences = []
		for segment in self.segments:
			sequence = segment.compute_sequence()
			# print sequence
			sequences.append(segment.compute_sequence())

		return sequences

	def mutate(self):
		"""
		This method will mutate all of the viral segments according to their 
		specified substitution rates.
		"""

		for segment in self.segments:
			segment.mutate()

	def generate_progeny(self, date):
		"""
		This method returns a list of progeny virus that have replicated from 
		the current virus.
		"""
		burst_size = randint(self.burst_size_range[0], \
			self.burst_size_range[1])
		# print burst_size
		progeny_viruses = []

		for i in range(burst_size):
			new_virus = self.replicate(date)
			progeny_viruses.append(new_virus)

		return progeny_viruses
		
	def replicate(self, date):
		"""
		This method returns a deep copy of the virus chosen to replicate.

		At the end, return the new virus. 

		mutate is guaranteed to be called, but not guaranteed to happen. Whether 
		a mutation occurs or not depends on the mutation rate of the virus.
		"""
		new_virus = deepcopy(self)
		new_virus.host = self.host
		new_virus.set_creation_date(date)
		new_virus.set_id()
		new_virus.set_parent(self)
		self.host.add_virus(new_virus)
		new_virus.mutate()

		return new_virus

	def generate_segment(self, segment_number, mutation_rate=0.03, \
		sequence=None, length=100):
		"""
		This method creates a segment with the parameters passed in.

		If the virus does not share these default parameters, then 
		"""
		segment = Segment(segment_number=segment_number, \
			mutation_rate=mutation_rate, sequence=sequence, length=length)

		return segment

	def generate_segments(self, num_segments):
		"""
		This method generates the specified number of segments.
		"""
		segments = []

		for i in range(num_segments):
			segments.append(self.generate_segment(segment_number=i))

		return segments

	def compute_genome_length(self):
		"""
		This method returns the length of the virus genome, summed over all    
		segments in the viral genome.
		"""
		length = sum(segment.length for segment in self.segments)
		return length

	# def get_sequences(self):
	# 	"""
	# 	This method will return a list of sequences, one for each 
	# 	segment.
	# 	"""
	# 	sequences = []

	# 	for segment in self.segments:
	# 		sequences.append(segment.get_sequence())

	# 	return sequences

	def set_burst_size_range(self, burst_size_range):
		"""
		This method will set the burst size range. The burst size range must
		be passed in as a two-element list or tuple, with minimum at the first 
		position, and maximum at the second position.
		"""
		if type(burst_size_range) not in [tuple, list]:
			raise TypeError("A tuple/list of two integers must be specified!")

		if len(burst_size_range) != 2:
			raise ValueError("A two-element tuple/list must be specified!")

		if type(burst_size_range[0]) != int or type(burst_size_range[1]) != int:
			raise TypeError("Integer values of burst sizes must be specified!")

		if burst_size_range[0] > burst_size_range[1]:
			raise ValueError("The burst size range must be specified as (min, max)!")
		else:
			self.burst_size_range = burst_size_range

	def set_creation_date(self, date):
		"""This method sets the creation date of the virus."""
		self.creation_date = date

	def set_replication_time(self, replication_time):
		if type(replication_time) != int:
			raise TypeError('An integer number of minutes must be specified!')
		else:
			self.replication_time = replication_time

	def set_id(self):
		"""
		This method sets the ID of the virus to be a unique string based on
		the string representation of the current time and a randomly chosen
		number.
		"""
		random_number = str(random())
		current_time = str(datetime.now())

		unique_string = random_number + current_time

		unique_id = hashlib.new('sha512')
		unique_id.update(unique_string)
		
		self.id = unique_id.hexdigest()

	def set_parent(self, parent_virus):
		"""This method records the ID of the virus' parent."""
		if parent_virus == None:
			self.parent = None
		elif not isinstance(parent_virus, Virus):
			raise TypeError('A Virus object must be specified!')
		else:
			self.parent = parent_virus

	# def SetSegments(self, list_of_segments):
	# 	"""
	# 	This method will override all segments present in the virus. This
	# 	is essentially syntactic sugar for changing a virus wholesale;
	# 	however, use with caution.
	# 	"""
	# 	self.segments = list_of_segments

	# def set_reassorted_status(self, status):
	# 	"""This is a helper method that will set the reassortant status."""
	# 	if status not in [True, False]:
	# 		raise TypeError('A Boolean status must be specified!')
	# 	else:
	# 		self.reassorted = status

	def is_reassorted(self):
		"""This method returns the reassortant status of the virus."""
		if len(self.get_parent) == 2:
			return True

		elif len(self.get_parent) == 1:
			return False








